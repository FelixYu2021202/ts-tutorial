var JSONSelect = require("JSONSelect");

exports.transform = function (ast, b /*builder*/) {

    // returned to caller so necessary modules can be "linked" in
    var dependencies = {};

    var funsWithSuperSelector = JSONSelect.compile(':has(:root > .value .body .type:val("SuperExpression"))');
    var superSelector = JSONSelect.compile(':has(:root > .type:val("SuperExpression"))');

    // object extend .{ operator
    JSONSelect.forEach(':has(:root > .property .type:val("ObjectExpression"))', ast,
        function (match) {
            var parent = match.parent;
            var hasSuper = 0;
            funsWithSuperSelector.forEach(match.property, function (prop) {
                var meth = prop.value;
                prop.value = bindFunSuper(meth);
                hasSuper++;
                superSelector.forEach(meth.body, function (sup) {
                    superExpr(sup);
                });
            });

            if (hasSuper) {
                var wrapExp = buildExtend(b.identifier("__Extendee__"), match.property);
                var exp = wrapSuper(match.object, wrapExp, superExtender(), "__Extendee__");
            } else {
                var exp = buildExtend(match.object, match.property);
            }

            parent.replace(match, exp);
        }
    );

    // prototype for <| operator
    JSONSelect.forEach(':has(:root > .type:val("PrototypeForExpression"))', ast,
        function (match) {
            var parent = match.parent;

            var hasSuper = 0;
            if (match.object.type === 'ObjectExpression') {
                funsWithSuperSelector.forEach(match.object, function (prop) {
                    var meth = prop.value;
                    if (prop.kind == 'init') {
                        prop.value = bindFunSuper(meth);
                    }
                    superSelector.forEach(meth.body, function (sup) {
                        hasSuper++;
                        superExpr(sup);
                    });
                });
            } else {
                superSelector.forEach(match.object, function (sup) {
                    hasSuper++;
                    superExpr(sup);
                });
            }

            if (hasSuper && match.object.type === 'FunctionExpression') {
                var wrapExp = buildPrototypeFor(b.identifier("__Proto__"), match.object);
                var exp = bindFunSuper(wrapExp, superProto(match.proto));
            } else if (hasSuper) {
                var wrapExp = buildPrototypeFor(b.identifier("__Super__"), match.object);
                var exp = wrapSuper(match.proto, wrapExp, []);
            } else {
                var exp = buildPrototypeFor(match.proto, match.object);
            }
            parent.replace(match, exp);
        }
    );

    JSONSelect.forEach(':has(:root > .body > .body .type:val("SuperExpression"))', ast,
        function (match) {
            console.log(match);
            match.parent.replace(match, bindFunSuper(match, null, true));
            superSelector.forEach(match.body, function (sup) {
                superExpr(sup);
            });
        }
    );

    // replace a super expression with the correct reference
    function superExpr (sup) {
        var parent = sup.parent;
        var grandparent = parent.parent;

        if (grandparent.type == 'CallExpression' &&
            grandparent.callee === parent) {
            superCall(sup);
        } else if (parent.type       == 'ExpressionStatement' ||
                parent.type          == 'AssignmentExpression' ||
                parent.type          == 'UpdateExpression' ||
                grandparent.operator == 'delete') {
            sup.parent.replace(sup, b.thisExpression());
        } else if (grandparent.type  == 'AssignmentExpression') {
            //superSet(sup);
            if (grandparent.operator == '=') {
                sup.parent.parent.parent.replace(sup.parent.parent, getSetCall("set", sup, sup.parent.parent.right));
                dependencies["set"] = true;
            } else {
                sup.parent.replace(sup, b.thisExpression());
            }
        } else {
            //superGet(sup);
            sup.parent.parent.replace(sup.parent, getSetCall("get", sup));
            dependencies["get"] = true;
        }
    }

    // replace super.meth() with __Super__.meth.call(this)
    function superCall (sup) {
        var mem = sup.parent;
        var call = mem.parent;
        mem.replace(sup, b.identifier("__Super__"));
        call.replace(mem,
            b.memberExpression(mem, b.identifier("call"), false));
        call.arguments.unshift(b.thisExpression());
    }

    function getSetCall (getset, sup, val) {
        return b.callExpression(
          b.identifier("__"+getset),
          [ b.identifier("__Super__"), propName(sup.parent), b.thisExpression() ].concat(val ? [val] : [])
        )
    }

    function propName (member) {
        return member.computed ? member.property : b.literal(member.property.name);
    }



    // for inline getter checks
    function superGet (sup) {
        var member = sup.parent;
        member.parent.replace(member, b.conditionalExpression(
            b.memberExpression(
              getProp(member.property),
              b.identifier("get"),
              false
            ),
            getSetPropCall("get", member.property),
            b.memberExpression(b.identifier("__Super__"), member.property, member.computed)
          ));
    }

    // for inline setter checks
    function superSet (sup) {
        var member = sup.parent;
        var assign = member.parent;
        var val = assign.right;
        var key = member.property;
        assign.parent.replace(assign, b.conditionalExpression(
            b.memberExpression(
              getProp(key),
              b.identifier("get"),
              false
            ),
            getSetPropCall("set", key, val),
            (member.replace(sup,b.thisExpression()),assign)
          ));
    }

    // used for inlining getter/setter checks
    function getProp (prop) {
        return b.callExpression(
          b.memberExpression(
            b.identifier("Object"),
            b.identifier("getOwnPropertyDescriptor"),
            false
          ),
          [ b.identifier("__Super__"), prop.name ? b.literal(prop.name) : prop ]
        )
    }
    // used for inlining getter/setter checks
    function getSetPropCall (getset, prop, val) {
        return b.callExpression(
          b.memberExpression(
            b.memberExpression(
              getProp(prop),
              b.identifier(getset),
              false
            ),
            b.identifier("call"),
            false
          ),
          [ b.thisExpression() ].concat(val ? [val] : [])
        )
    }

    function superProto (proto) {
      return [b.variableDeclaration( "var",
          [b.variableDeclarator(
            b.identifier("__Proto__"),
            proto),
          b.variableDeclarator(
            b.identifier("__Super__"),
            b.memberExpression(
              b.identifier("__Proto__"),
              b.identifier("prototype"),
              false))]
          )];
    }

    function superExtender () {
        return [b.variableDeclaration(
          "var",
            [b.variableDeclarator(
            b.identifier("__Super__"),
            b.callExpression(
              b.memberExpression(
                b.identifier("Object"),
                b.identifier("getPrototypeOf"),
                false
              ),
              [b.identifier("__Extendee__")]
            ))]
        )];
    }

    function wrapSuper (super, exp, pre, name) {
      return b.callExpression(
          b.functionExpression(null, [],
            b.blockStatement(
              [b.variableDeclaration("var",
                [b.variableDeclarator(
                  b.identifier(name||"__Super__"),
                  super)])
              ].concat(pre||[])
               .concat([b.returnStatement(exp)])
            ),
            false, false),
          []
        );
    }

    function expStmt (expr) {
        return b.expressionStatement(expr);
    }

    function buildExtend (obj, extension) {
        dependencies["extend"] = true;
        return b.callExpression(
            b.identifier("__extend"),
            [obj, extension]
        );
    }

    function buildPrototypeFor (proto, obj) {
        var type = obj.type == "FunctionExpression" ? "Function" :
                   obj.type == "ObjectExpression"   ? "Object" :
                   "Literal";
        dependencies["prototypeFor"+type] = true;
        return b.callExpression(
            b.identifier("__prototypeFor"+type),
            [proto, obj]
        );
    }


    function bindFunSuper (fun, pre, noInit) {
        return b.callExpression(
          b.functionExpression( null, [],
            b.blockStatement(
              (pre||[]).concat([b.variableDeclaration( "var",
                [b.variableDeclarator(
                  b.identifier("__makeFn"),
                  b.functionExpression( null,
                    [b.identifier("__Super__")],
                    b.blockStatement(
                      [b.variableDeclaration( "var",
                        [b.variableDeclarator(b.identifier("__FN__"), fun)]
                      ), b.expressionStatement(b.callExpression(
                          b.memberExpression(
                            b.identifier("Object"),
                            b.identifier("defineProperty"), false
                          ),
                          [b.identifier("__FN__"), b.identifier("__DMP__"), b.objectExpression([{
                            key: b.identifier("value"),
                            kind: "init",
                            value: b.identifier("__makeFn")}])]
                        )), b.returnStatement(b.identifier("__FN__"))]
                    ), false, false
                  )
                )]
              ), b.returnStatement(b.callExpression(
                  b.identifier("__makeFn"),
                  noInit ? [] : [b.identifier("__Super__")]
                ))])
            ), false, false, true
          ), []
        );
    }

    return dependencies;
};

